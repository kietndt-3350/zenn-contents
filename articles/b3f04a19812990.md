---
title: "React Queryでサーバー状態＆キャッシュ管理：useEffect／素のReduxより選ぶ理由—Redux／Zustandと上手に併用"
emoji: "🚀"
type: "tech"
topics: ["react", "reactquery"]
published: true
---

# はじめに

みなさんは、一覧 ↔ 詳細を行き来しただけで毎回ローディング、更新後に画面が古いまま…といった “サーバー由来データの扱いづらさ” を感じたことはありませんか？  
**この記事では、そのつらさを「React Query」で体系的に解決する方法**を、実務の設計指針と具体コードでまとめます。

**この記事で分かること（TL;DR）**

-   **Server state と Client state の切り分け**（まず概念の交通整理）
-   **React Query の基本 3 本柱**：`useQuery`（読む）／`useMutation`（書く）／**Query Invalidation**（整合）
-   **queryKey 設計の型**（`['entity','scope',params]`）と **invalidate の 3 パターン**
-   UX を良くする実践：`placeholderData` で前値つなぎ、`enabled` で依存クエリ制御、**Infinite Query**
-   **Prefetch/SSR（dehydrate/HydrationBoundary）**で初回表示を高速化
-   **Devtools**でキャッシュ・stale の可視化と運用

:::message
**結論（先出し）**  
**「useEffect 地獄」から脱却する最短路は、Server state を React Query に委譲し、“共通ルール化” すること。**  
以降の章では、この方針を実装に落とし込む具体テクニックを順に解説します。
:::

---

## 1. 背景と課題：　なぜ useEffect／素の Redux だけでサーバー由来データを扱うのは　“しんどい”　のか

フロントエンド開発者なら 一度は経験ありますよね。リスト／詳細を行き来していると、こんな “あるある” が起きがちです 👇

-   一覧に戻るたびに 最初からローディング
-   同じリクエストが 複数コンポーネントで重複発火
-   loading／error／data の管理が あちこちに重複 → メンテしんどい
-   タブ復帰時の refetch タイミングが合わない（したり・しなかったり）
-   作成／更新／削除のあと どれを invalidate すべきか迷う → UI が 同期しない

## 初学者がやりがちな　「まずは動くやつ」 💡

React を触り始めた頃は、「とりあえず useEffect で fetch して useState に入れる」 という実装になりがちです。最初は動きますが、画面数や機能が増えるほど前述の課題が表面化します。

```tsx
import { useEffect, useState } from "react";

type User = { id: number; name: string };

export function UsersList() {
    const [data, setData] = useState<User[] | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        let aborted = false;

        setLoading(true);
        setError(null);

        fetch("/api/users")
            .then((r) => {
                if (!r.ok) throw new Error("Network error");
                return r.json() as Promise<User[]>;
            })
            .then((json) => {
                if (!aborted) setData(json);
            })
            .catch((e) => {
                if (!aborted) setError(e as Error);
            })
            .finally(() => {
                if (!aborted) setLoading(false);
            });

        // コンポーネントのアンマウント時に処理を中断
        return () => {
            aborted = true;
        };
    }, []); // 一覧ページから戻るたびに再実行されることがある

    if (loading) return <p>Loading...</p>;
    if (error) return <p role="alert">Error: {error.message}</p>;
    if (!data) return null;

    return (
        <ul>
            {data.map((u) => (
                <li key={u.id}>{u.name}</li>
            ))}
        </ul>
    );
}
```

この “素朴な実装” は、次のようなスケール問題を引き起こします 🫠

-   共有キャッシュがない → 画面をまたぐと 毎回 fetch、戻った瞬間も 再ローディング
-   重複リクエスト → 同一データを複数コンポーネントが個別に取得
-   状態の定型コード（loading／error／data）を 各所で量産 → DRY ルール違反（修正コスト増・不整合リスク）
-   失敗時の retry や backoff、キャンセル などを 毎回自前で実装
-   作成／更新／削除後の再取得方針（どこをいつ更新？）が 画面ごとバラバラ

:::message
この章では “よくあるつまずき” を共有するところまで。
次章で Client state と Server state の違い を整理し、その後で React Query がどう解決するか を丁寧に見ていきます ✅
:::

# 2. Client state と Server state を切り分ける ✂️

まずは “何を管理しているのか” をハッキリさせましょう。性質の違う 2 種類の state を混ぜてしまうと、途端にコードも運用も苦しくなります。

🟦 Client state

-   例：モーダルの開閉、検索入力の文字列、選択中のフィルター、フォームのステップ など
-   特徴：アプリ内で完結し、外部要因で勝手に変わらない
-   ゴール：UI 体験を組み立てるための“今ここ”の状態を、シンプルに・予測可能に持つ

🟨 Server state

-   例：API から取得する posts / users / orders など
-   特徴：別の場所・別の要因でも更新され得る（自分の知らないところで変わる）
-   向き合う課題：fresh/stale（新鮮／古い）, 同期, retry, ページネーション, 無限スクロール, キャッシュ＆GC, 重複排除（dedupe）, フォーカス復帰／再接続時の再取得…など盛りだくさん ⚙️

:::message
まとめ：Client は“UI の都合”／Server は“データの都合”。ここを分けて考えるのが第一歩。
:::

# 3. 「useEffect ＋ useState 　（＋ Redux/Zustand） に全部投入」　で抱えがちな自前タスク 🧳

「まずは動く」を超えて 効率的＆高パフォーマンス を目指すと、次のような仕組みを自前実装する必要が出てきます。

-   🧠 キャッシュ：画面遷移をスムーズに、無駄な refetch を回避
-   🧩 dedupe（重複リクエスト抑止）：同じデータ取得の二重発火を防ぐ
-   🔁 retry／backoff・キャンセル・フォーカス復帰／再接続時の再取得
-   ♻️ invalidate 戦略：作成／更新／削除の後、どのデータを再取得すべき？
-   ⏱️ stale/fresh ポリシー＆キャッシュのライフサイクル（GC） 設計

:::message
そして…その結果どうなるか？ 👇

コードは肥大・重複して方針がブレやすく、ローディング点滅や不適切な refetch で UX はぎこちなく、画面／コンポーネント間の同期ズレなど細かな不具合も起きがちです 🥲
:::

# 4. React Query は Server state のための強力ツール 🚀

結論から言うと、**React Query は Server state を扱うための“標準装備”をまるっと提供してくれる頼れる相棒です。面倒ごとを設定と約束ごと**で片付け、コード量を減らしつつ UX を底上げしてくれます。

何がうれしいの？ 機能ざっくり一覧 ⭐

-   キャッシュ by queryKey：同じ queryKey なら取得結果を共有。戻る操作でも即時表示
-   Stale-While-Revalidate：キャッシュを即描画しつつ、必要に応じてバックグラウンドで再取得
-   staleTime / gcTime：データの有効期間を制御
-   重複排除（dedupe）／retry：同一リクエストの二重発火を抑止、一時的な失敗は自動リトライ
-   フォーカス復帰・再接続での再取得：ユーザーに常に新鮮なデータを提供
-   invalidate 戦略が簡単：変更後に必要なクエリだけを的確に更新
-   ページネーション／無限スクロール：useInfiniteQuery でスムーズに
-   Devtools：キャッシュ状態や stale/fresh、リクエスト状況を可視化
-   Prefetch／Hydration：Next.js 等での事前取得・SSR 連携もスムーズ

## 4.1. 最低限のセットアップ ⚙️

導入方法:

```
npm i @tanstack/react-query

pnpm add @tanstack/react-query

yarn add @tanstack/react-query

bun add @tanstack/react-query
```

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const qc = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 30_000, // この間はネットワーク行かずキャッシュ優先
            gcTime: 5 * 60_000, // 非アクティブなキャッシュを破棄するまでの猶予
            refetchOnWindowFocus: true,
        },
    },
});

export function App() {
    return (
        <QueryClientProvider client={qc}>
            <YourRoutes />
        </QueryClientProvider>
    );
}
```

では、React Query の主要な 3 つの概念――Queries、Mutation、Query Invalidation――を一緒に見ていきましょう。

## 4.2. Queries： まず　“読込処理”　をきれいにする 📖

`useQuery` は 「同じ入力 → 同じ結果」 な取得を扱うフックです。
ポイントは queryKey の設計 と クエリのライフサイクル（stale/fresh, GC）。

### 4.2.1. Query Key の設計指針 🔑

-   配列で階層化：`['users', 'list', { page, q }]` のように、エンティティ → 種別 → パラメータ
-   直感的に invalidate できる粒度：`['users']` で一覧系ぜんぶ、`['users', 'detail', id]` で 1 件だけ
-   シリアライズ可能な値のみ（関数やクラスは不可）

```tsx
import { useQuery } from "@tanstack/react-query";

async function fetchUsers(params: { page: number; q?: string }) {
    const qs = new URLSearchParams({
        page: String(params.page),
        q: params.q ?? "",
    });
    const res = await fetch(`/api/users?${qs}`);
    if (!res.ok) throw new Error("Failed to fetch users");
    return (await res.json()) as { items: User[]; total: number };
}

export function useUsers(params: { page: number; q?: string }) {
    return useQuery({
        queryKey: ["users", "list", params],
        queryFn: () => fetchUsers(params),
        staleTime: 30_000,
        gcTime: 5 * 60_000,
        // v5 では keepPreviousData が廃止されたため、前ページのデータを引き継ぎたい場合は placeholderData を使用する
        placeholderData: (prev) => prev,
        // API 仕様に依存するデータ整形は select 内で行うと、UI コンポーネント側のコードをシンプルに保てる
        select: (data) => data.items,
    });
}
```

:::message
💡 Tips
・ UI に寄せた整形（ソート/マッピングなど）は `select` にまとめて、コンポーネントからロジックを追い出す
・ キャッシュ共有を効かせるため、同じ入力は同じ key を必ず生成する
:::

### 4.2.2. Dependent Queries （依存関係のある取得） 🔗

「詳細を取ってから、そのユーザーの注文一覧を取得」などは `enabled` で制御。

```tsx
const user = useQuery({
    queryKey: ["users", "detail", userId],
    queryFn: () => fetchUser(userId),
});

const orders = useQuery({
    queryKey: ["orders", "byUser", userId],
    queryFn: () => fetchOrdersByUser(userId!),
    enabled: !!userId && !!user.data, // ユーザーが取れてから動く
});
```

### 4.2.3. Infinite Query （無限スクロール） 🧵

Infinite Query は、総件数や最終ページが読めない長い一覧（例：フィード）で、「もっと見る」やスクロールに合わせてカーソルを辿りつつ順次データを読み込みたいときに使います。

```tsx
import { useInfiniteQuery } from "@tanstack/react-query";

export function useUserFeed() {
    return useInfiniteQuery({
        queryKey: ["feed"],
        queryFn: ({ pageParam }) => fetchFeed({ cursor: pageParam }),
        initialPageParam: null as string | null,
        getNextPageParam: (last) => last.nextCursor ?? null,
        staleTime: 10_000,
    });
}
```

## 4.3. Mutations： 「書込処理」 は副作用とセットで ✍️

`useMutation` は 作成／更新／削除 を扱います。コアは 楽観的更新（optimistic update） と 正しい invalidate。

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

function useCreateUser() {
    const qc = useQueryClient();

    return useMutation({
        mutationFn: async (payload: { name: string }) => {
            const res = await fetch("/api/users", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!res.ok) throw new Error("create failed");
            return (await res.json()) as User;
        },
        // 楽観的更新
        onMutate: async (payload) => {
            await qc.cancelQueries({ queryKey: ["users", "list"] });

            const prev = qc.getQueryData<User[]>([
                "users",
                "list",
                { page: 1 },
            ]);
            // 便宜上 page=1 のリストの先頭に挿入
            if (prev) {
                qc.setQueryData<User[]>(
                    ["users", "list", { page: 1 }],
                    [
                        { id: -1, name: payload.name }, // 仮ID
                        ...prev,
                    ]
                );
            }
            // ロールバック用
            return { prev };
        },
        onError: (_err, _vars, ctx) => {
            if (ctx?.prev) {
                qc.setQueryData(["users", "list", { page: 1 }], ctx.prev);
            }
        },
        onSettled: () => {
            // 最終的に正データで整合
            qc.invalidateQueries({ queryKey: ["users"] });
        },
    });
}
```

:::message
💡 覚え方
読む＝ useQuery／書く＝ useMutation
書いたら 影響範囲のクエリを invalidate（または setQueryData で直接調整）
:::

## 4.3. Query Invalidation： どこを　“更新扱い”　にする？ ♻️

基本の 3 パターンを使い分けます。

1. 「一覧が変わる」系（作成・削除後など）

```tsx
qc.invalidateQueries({ queryKey: ["users", "list"] });
```

2. 「詳細 1 件だけ変わる」系（編集後）

```tsx
qc.invalidateQueries({ queryKey: ["users", "detail", userId] });
// もしくは即時反映派：
// qc.setQueryData(["users", "detail", userId], (prev: User | undefined) =>
//   prev ? { ...prev, name: form.name } : prev
// );
```

3. 広めに“カテゴリ一式”を更新したい

```tsx
qc.invalidateQueries({ queryKey: ["users"] }); // users配下すべて
```

:::message
注意点
一律で “全部 invalidate” は 過剰 refetch のもと。
→ key の設計 を最初に丁寧に切ると楽になります。
:::

## 4.4. エラーハンドリングと UX 🧯

-   再試行：一時的な失敗は retry（デフォルト 3 回）。API の性質に合わせて調整。
-   ユーザー導線：onError で toast、status で CTA（再試行ボタン）を出す。
-   アクセス制御：401/403 は onError でログインモーダルや Keycloak リダイレクトへ。

```tsx
const q = useQuery({
    queryKey: ["users", "detail", id],
    queryFn: () => fetchUser(id),
    retry: (failureCount, error: any) => {
        if (error?.status === 404) return false;
        return failureCount < 2;
    },
});
```

## 4.5. Prefetch / SSR （Next.js 連携） 🚚

初回表示がやたら遅い、skeleton がチラつく、あるいはウォーターフォール fetch で体験がカクつく ── そんな時は、
=> prefetch と SSR（`dehydrate` / `HydrationBoundary` 併用）でサーバー側で先に描画し、キャッシュをクライアントへ受け渡し。チラつきを抑え、first paint を加速できます。

```tsx
// 例：ルーティング遷移前に先読み
await queryClient.prefetchQuery({
    queryKey: ["users", "detail", id],
    queryFn: () => fetchUser(id),
});
```

## 4.6. Devtools で “見える化” 🔍

キャッシュ・stale 状態・アクティブクエリが一目で分かります。
開発中は必ず入れて、本番ビルドで外します。

```tsx
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

<QueryClientProvider client={qc}>
    <App />
    <ReactQueryDevtools initialIsOpen={false} />
</QueryClientProvider>;
```

## 4.7. よくある　“つまずき”　と対処集 🩹

-   リストがチラつく → placeholderData: (prev) => prev で “前値つなぎ”、または骨組み UI。
-   依存関係ループ → enabled で段階的に起動。
-   フォーム送信後に画面が古い → onSuccess で 該当 key だけ invalidate。
-   クエリ関数で UI 仕様の整形をしてしまう → select で UI への最小変換に閉じ込める。
-   大量のページング → useInfiniteQuery と カーソル方式 を検討。

# 5. まとめ 🧃

というわけで今日は React Query 周りをいろいろ見てきました。これで “useEffect 地獄” にお別れ、これからは 相棒＝高性能な React Query を迎え入れましょう！🎉

-   Server state の面倒は React Query に委譲：キャッシュ／stale／retry／invalidate を“共通ルール化”。useEffect 乱立から卒業。
-   要は queryKey 設計：['entity','scope',params] を一貫。読む＝ useQuery／書く＝ useMutation、書いたら必要十分な範囲だけ invalidate。
-   体験をなめらかに：placeholderData で“前値つなぎ”、enabled で依存取得を安全起動、長い一覧は Infinite Query。
-   初回をサクッと：Next.js なら prefetch + SSR（dehydrate/HydrationBoundary） でチラつき減＆first paint 加速。
-   見える化で安心：開発中は Devtools 常時オンで stale/fresh やリクエスト状況を即チェック。

読んでいただき、ありがとうございました！🙏✨
