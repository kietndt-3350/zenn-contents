---
title: "Domain-Driven Designï¼ˆDDDï¼‰ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æ§‹ç¯‰ï¼šè€ƒãˆæ–¹ã¨æŠ¼ã•ãˆã‚‹ã¹ãè¦ç‚¹"
emoji: "ğŸ“–"
type: "tech"
topics: ["rust", "ddd", "designpattern"]
published: false
---

## ã¯ã˜ã‚ã« âœ¨

ã¿ãªã•ã‚“ã“ã‚“ã«ã¡ã¯ã€‚ä»Šå›ã¯å°‘ã—â€œæ­¯ã”ãŸãˆã®ã‚ã‚‹â€ãƒ†ãƒ¼ãƒã«æŒ‘æˆ¦ã—ã¾ã™ã€‚
ãã‚ŒãŒ DDDï¼ˆDomain-Driven Designï¼ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆï¼‰ ã§ã™ã€‚DDD ã¯å­¦ã¶ä¾¡å€¤ã®é«˜ã„ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã ã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚ç§è‡ªèº«ã®å®Ÿå‹™çµŒé¨“ã¯ã¾ã é•·ãã‚ã‚Šã¾ã›ã‚“ã®ã§ã€ä¸ååˆ†ãªç‚¹ã‚‚ã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãœã²ã”æŒ‡æ‘˜ãƒ»ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ã„ãŸã ã‘ã‚Œã°å¹¸ã„ã§ã™ã€‚

> Domain-driven design (DDD) is an approach to developing software for complex needs by deeply connecting the implementation to an evolving model of the core business concepts.

DDD ã¯ã€Œç‰¹å®šãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®å‹ã€ã§ã¯ãªãã€æ¥­å‹™ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ä¸­å¿ƒã«æ€è€ƒã‚’æ•´ç†ã™ã‚‹ãŸã‚ã®æ–¹æ³•è«–ã§ã™ã€‚æœ¬ç¨¿ã§ã¯ã€ä¸»è¦ãªæ¦‚å¿µã€å®ˆã‚‹ã¹ãåŸå‰‡ã€ãã—ã¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒå¤§ãããªã£ã¦ã‚‚ã‚³ãƒ¼ãƒ‰ãŒæ··ä¹±ã—ãªã„ãŸã‚ã®è€ƒãˆæ–¹ã‚’ã¾ã¨ã‚ã€æœ€å¾Œã« Rust ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã§ã® 1 ã¤ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ ã‚’é€šã—ã¦å…·ä½“åŒ–ã—ã¾ã™ã€‚æƒ³å®šã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚

```
domain/          # model (Entity/VO), repository (ports), domain services
application/     # usecases (orchestration, transaction boundary)
infrastructure/  # adapters (DB/Keycloak/Mail/Storage/Webhook)
interface/       # web handlers, middleware, routes, batch
registry/        # wiring/DI: bind ports â†” adapters
shared/          # cross-cutting: error, time, ids...
```

## æˆ¦è¡“çš„ DDD ã¨ã¯ï¼Ÿ ãªãœã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’é¸ã¶ã®ã‹ï¼Ÿ ğŸ¤”

ã¾ãšã€æœ¬è¨˜äº‹ã§ä¸»ã«æ‰±ã†ã®ã¯ **ã€Œæˆ¦è¡“çš„ DDDã€** ã§ã™ã€‚

æˆ¦è¡“çš„ DDD ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã‚’å…·ä½“çš„ãªã‚³ãƒ¼ãƒ‰ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ãŸã‚ã® è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ç¾¤ ã§ã™ã€‚
æ¥­å‹™ã®ä¸­æ ¸æ¦‚å¿µã‚’ **Entity / Value Object / Aggregate** ã¨ã—ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã€**Use Case / Application Service** ã§ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¾ã™ã€‚

DBãƒ»HTTPãƒ»IdPãƒ»ãƒ¡ãƒ¼ãƒ«ãªã©ã®ã‚¤ãƒ³ãƒ•ãƒ©ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒå®šç¾©ã—ãŸ **Portï¼ˆæœ¬è¨˜äº‹ã§ã¯ Rust ã® trait ã§å®Ÿè£…ã™ã‚‹ Repository / IdProvider / Mailer â€¦ï¼‰** ã«æ¥ç¶šã™ã‚‹ **Adapter** ã¨ã—ã¦æ‰±ã„ã¾ã™ï¼ˆã„ã‚ã‚†ã‚‹ãƒ˜ã‚­ã‚µã‚´ãƒŠãƒ«ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ãƒãƒ¼ãƒˆ&ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ã€‚

ä¸€æ–¹ã§ã€ãã®æ ¹åº•ã«ã‚ã‚‹ **DDD ã®æ€æƒ³** ã¯ã€Œãƒ‰ãƒ¡ã‚¤ãƒ³ï¼ˆæ¥­å‹™é ˜åŸŸï¼‰ã‚’ä¸­å¿ƒã«è¨­è¨ˆã™ã‚‹ã€ã¨ã„ã†è€ƒãˆæ–¹ã§ã™ã€‚

ãªãœãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’æ‹ ã‚Šæ‰€ã«ã™ã‚‹ã®ã‹ï¼Ÿ ãã‚Œã¯é¡§å®¢ï¼ˆãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆï¼‰ãŒæœ€ã‚‚æ·±ãç†è§£ã—ã¦ã„ã‚‹å¯¾è±¡ã ã‹ã‚‰ã§ã™ã€‚ç§ãŸã¡ã¯é¡§å®¢ã®è¦ä»¶ã«æ²¿ã£ã¦é–‹ç™ºã™ã‚‹ãŸã‚ã€ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶ã‚’é¡§å®¢ã»ã©ç†è§£ã—ã¦ã„ã‚‹äººã¯ã„ã¾ã›ã‚“ã€‚é¡§å®¢ãŒã‚·ã‚¹ãƒ†ãƒ ã‚’èª¬æ˜ã™ã‚‹ã¨ãã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã®è¨€è‘‰ã§èªã‚Šã¾ã™ã€‚ã‚†ãˆã«ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ä¸­å¿ƒã«æ®ãˆã€èª°ã‚‚ãŒå…±æœ‰ã§ãã‚‹ãƒ¢ãƒ‡ãƒ«ã¸è½ã¨ã—è¾¼ã‚€ã®ãŒç§ãŸã¡ã®ä»•äº‹ã§ã™ã€‚

ç«¯çš„ã«è¨€ãˆã°ã€DDD ã¨ã¯ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã ã‘ã§ãªãéæŠ€è¡“è€…ã§ã‚ã‚‹é¡§å®¢ã‚‚æ ¸å¿ƒã‚’æ´ã‚ã‚‹ã‚ˆã†ã«è¨­è¨ˆã™ã‚‹ã“ã¨ã§ã™ã€‚

æˆ¦è¡“çš„ DDD ã‚’å®Ÿè·µã™ã‚‹ä¸Šã§æœ€ã‚‚é›£ã—ã„ã®ã¯ã€æ¦‚å¿µã‚’æ­£ã—ãè¦‹æ¥µã‚ã€å„è¦ç´ ã‚’ **ç„¶ã‚‹ã¹ãå ´æ‰€ï¼ˆãƒ¬ã‚¤ãƒ¤ã‚„å¢ƒç•Œï¼‰** ã«é…ç½®ã™ã‚‹ã“ã¨ã§ã™ã€‚

### ãªãœæˆ¦è¡“çš„ DDD ã‚’ã‚’é¸ã¶ã®ã‹ï¼ˆç‰¹ã« Rust ã§ï¼‰ ğŸ™Œ

- å€‹ã€…ã®è¦ç´ ã®è‚¥å¤§åŒ–ã‚’é˜²ãï¼šã€€ãƒ‰ãƒ¡ã‚¤ãƒ³ã¨ I/O ã‚’åˆ†é›¢ã—ã€è²¬å‹™ã®æ··åœ¨ã‚’æŠ‘ãˆã‚‹ã€‚
- ãƒ†ã‚¹ãƒˆã—ã‚„ã™ãã€ç½®ãæ›ãˆå®¹æ˜“ï¼š Port/Adapter ã§ãƒ¢ãƒƒã‚¯æ¤œè¨¼ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©å·®ã—æ›¿ãˆãŒç°¡å˜ã€‚
- å¢ƒç•ŒãŒæ˜ç¢ºï¼š Bounded Context ã§ç”¨èªãƒ»è²¬å‹™ã‚’åˆ‡ã‚Šåˆ†ã‘ã€è¡çªã‚’æ¸›ã‚‰ã™ã€‚
- Rust ã¨ç›¸æ€§è‰¯ï¼š å¼·ã„å‹ï¼‹ trait ï¼‹ enum ã§ä¸å¤‰æ¡ä»¶ã¨ã‚¨ãƒ©ãƒ¼ã‚’æ˜å¿«ã«è¡¨ç¾ã€‚

### æˆ¦è¡“çš„ DDD ã‚’ä½¿ã†ã¹ãå ´é¢ âœ…

- è¤‡é›‘ã§å¤‰åŒ–ã®å¤šã„ãƒ‰ãƒ¡ã‚¤ãƒ³ã€é•·å¯¿å‘½ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆ
- ç›£æŸ»æ€§ï¼æ•´åˆæ€§ãŒé‡è¦ï¼ˆãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆã€æ¨©é™ã€ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ç­‰ï¼‰
- è¤‡æ•°ãƒãƒ¼ãƒ ãŒä¸¦è¡Œé–‹ç™ºã—ã€æ˜ç¢ºãªå¢ƒç•ŒãŒå¿…è¦

### æˆ¦è¡“çš„ DDD ãŒä¸è¦ ãªå ´é¢ ğŸ™…

- å°ã•ãªè£œåŠ©ãƒ„ãƒ¼ãƒ«ã€å˜ç´”ãª CRUD ç®¡ç†ã€çŸ­æœŸé‹ç”¨
- è¶…çŸ­æœŸ MVPï¼ˆãŸã ã—å°†æ¥ æˆ¦è¡“çš„ DDD ã¸ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹â€œç€åœ°ç‚¹â€ã¯æ„è­˜ã—ã¦ãŠãï¼‰

## æˆ¦è¡“çš„ DDD ã§å®ˆã‚‹ã¹ããƒ«ãƒ¼ãƒ« ğŸ“–

æˆ¦è¡“çš„ DDD ã‚’é‹ç”¨ã—ã¦ã„ãä¸­ã§ã€ã€Œã‚³ãƒ¼ãƒ‰ã‚’ãã‚Œã„ãƒ»ä¸€è²«ãƒ»ä¿å®ˆã—ã‚„ã™ãä¿ã¤ã€ãŸã‚ã®å®Ÿè·µãƒ«ãƒ¼ãƒ«ã‚’ã¾ã¨ã‚ã¾ã—ãŸã€‚ğŸ‘‡

- Domain ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯/ã‚¤ãƒ³ãƒ•ãƒ©ã‚’ import ã—ãªã„
  Entity / VOã€æ¥­å‹™ãƒ«ãƒ¼ãƒ«ã€Portï¼ˆæœ¬è¨˜äº‹ã§ã¯ Rust ã® trait ã§å®Ÿè£…ï¼‰ã®ã¿ã€‚sqlx ã‚„ axum ãªã©å¤–éƒ¨ SDK ç¦æ­¢ã€‚

- Use Case ã« SQL/HTTP ã‚’æ›¸ã‹ãªã„â€”Port/Repository çµŒç”±ã®ã¿
  Application å±¤ã¯ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ¶å¾¡ã«å°‚å¿µã€‚

- Handler ã¯â€œè–„ãâ€
  å…¥åŠ›ã® parse/validate â†’ Use Case å‘¼ã³å‡ºã— â†’ ã‚¨ãƒ©ãƒ¼ã‚’ HTTP/DTO ã« mapã€‚æ¥­å‹™ãƒ­ã‚¸ãƒƒã‚¯ã¯ç½®ã‹ãªã„ã€‚

- ã‚¨ãƒ©ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ˜ç¢ºã«ï¼ˆAppError / RepoErrorï¼‰
  DB/HTTP ã®ç”Ÿã‚¨ãƒ©ãƒ¼ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³å¤–ã¸æ¼ã‚‰ã•ãªã„ã€‚enum ã§æ•´ç†ã—ã€æ®µéšçš„ã«å¤‰æ›ã€‚

- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¢ƒç•Œã¯ Applicationï¼ˆUnit of Workï¼‰
  è¤‡æ•°ãƒªãƒã‚¸ãƒˆãƒªã«è·¨ã‚‹å ´åˆã¯ Use Case ã§ BEGIN/COMMIT/ROLLBACK ã‚’ç®¡ç†ã€‚Repo å´ã§å‹æ‰‹ã«é–‹ã‹ãªã„ã€‚

- ãƒ¬ã‚¤ãƒ¤ã”ã¨ã«ãƒ†ã‚¹ãƒˆï¼š Domainï¼ˆç´”ç²‹ãƒ»é«˜é€Ÿï¼‰â†’ Applicationï¼ˆfake/in-memory repoï¼‰â†’ Infrastructureï¼ˆçµ±åˆï¼‰â†’ Interfaceï¼ˆHTTPï¼‰
  ã®é †ã«ã€å†…å´ã§è»½ã„å±¤ã‹ã‚‰å¤–å´ã§é‡ã„å±¤ã¸ã¨åºƒã’ã¦ã„ãï¼ˆãƒ†ã‚¹ãƒˆã‚³ã‚¹ãƒˆãŒä½ã„é †ï¼‰ã€‚

- ãƒ¦ãƒ“ã‚­ã‚¿ã‚¹è¨€èªã‚’å¾¹åº•
  å‹å/é–¢æ•°åã¯â€œæ¥­å‹™ç”¨èªâ€ã§ã€‚æŠ€è¡“å¯„ã‚Šã®æ›–æ˜§ãªå‘½åã¯é¿ã‘ã‚‹ã€‚

- æ–°ã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ ã®æ‰‹é †ã¯ä¸€å®šã«
  Portï¼ˆdomainï¼‰â†’ Use Case â†’ Adapterï¼ˆinfraï¼‰â†’ Wiringï¼ˆregistryï¼‰â†’ Test ã®é †ã§å°ã•ãå®Œçµã€‚

## ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ™‚ãƒ»ã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ æ™‚ã«è¿·å­ã«ãªã‚‰ãªã„æ€è€ƒæ³• ğŸ§ 

ã¤ãã¯ã€æˆ¦è¡“çš„ DDD ã‚’å®Ÿå‹™ã§ä¸€ç•ªã‚€ãšã‹ã—ãæ„Ÿã˜ã‚‹ãƒã‚¤ãƒ³ãƒˆ â€•â€•ã€Œå®Ÿè£…ã®é †ç•ªã€ã€Œè²¬å‹™ã®ç½®ãå ´æ‰€ã€ã€Œå¢—ç¯‰æ™‚ã®è¿·å­å›é¿ã€â€•â€• ã«ã¤ã„ã¦ã§ã™ã€‚
â€œä½•ã‹ã‚‰æ‰‹ã‚’ã¤ã‘ã€ä½•ã‚’ã©ã“ã«ç½®ã‘ã°ã‚ˆã„ã‹ï¼Ÿâ€ ã‚’ã€æ‰‹é †åŒ–ã—ã¦ãŠãã¾ã™ã€‚

ä»¥ä¸‹ã®æ‰‹é †ã¨ã€ãã‚Œã‚’å®Ÿéš›ã®ã‚¹ã‚¿ãƒ‡ã‚£ã‚±ãƒ¼ã‚¹ã«ã©ã†é©ç”¨ã™ã‚‹ã‹ã‚’è¦‹ã¦ã„ãã¾ã—ã‚‡ã†ã€‚
ã“ã“ã§ã¯ã€ã‚¢ãƒ—ãƒªã«æ–°ã—ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã‚±ãƒ¼ã‚¹ã‚’ä¾‹ã«ã—ã¾ã™ã€‚

`POST /contents/:id/publish` â€” è¨˜äº‹ã‚’ draft ã‹ã‚‰ published ã«å¤‰æ›´ã—ã€ãã®å¾Œã« Webhook é€ä¿¡ ã¨ ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ ã‚’è¡Œã„ã¾ã™ã€‚

### Step 0: ã‚³ãƒ¼ãƒ‰å‰ã«ã€Œ3 è¡Œè¦ä»¶ã€ã‚’æ›¸ã

- å…¥åŠ›: contentId
- æœŸå¾…çµæœ: è¨˜äº‹ãŒ Published ã«ãªã‚Šã€204 No Content ã‚’è¿”ã™
- å¤±æ•—: å­˜åœ¨ã—ãªã„ï¼æ—¢ã«å…¬é–‹æ¸ˆã¿ï¼DB ã‚¨ãƒ©ãƒ¼ï¼Webhookãƒ»ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚¨ãƒ©ãƒ¼

> ç›®çš„ï¼šã‚³ãƒ¼ãƒ‰ã«æ‰‹ã‚’ä»˜ã‘ã‚‹å‰ã«ã€é–‹ç™ºè€…ãƒ»éé–‹ç™ºè€…ã®åŒæ–¹ãŒåŒã˜ç†è§£ã‚’æŒã¤ã“ã¨ã€‚

### Step 1: Domain å…ˆè¡Œ ï¼ˆãƒ¢ãƒ‡ãƒ«ã¨ãƒ«ãƒ¼ãƒ«ï¼‰

- æ—¢å­˜ Content ã« publish() ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ ï¼šDraft â†’ Published ã®ã¿å¯ã€title å¿…é ˆ
- ã“ã“ã§ SQL/HTTP ã‚’å…¥ã‚Œãªã„

```rust
// domain/model/content.rs
use crate::model::content::ContentStatus;

impl Content {
  pub fn publish(&mut self) -> Result<(), &'static str> {
    if self.status == ContentStatus::Published { return Err("already published"); }
    if self.title.is_empty() { return Err("title required"); }
    self.status = ContentStatus::Published;
    Ok(())
  }
}
```

### Step 2: Portï¼ˆtraitï¼‰ã‚’å®šç¾© ï¼ˆI/O ã‚’è¿½ã„å‡ºã™ï¼‰

- æœ€å°é›†åˆï¼šContentRepository / WebhookPublisher / MailSender
- æˆ»ã‚Šå€¤ã¯ ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ + ãƒ‰ãƒ¡ã‚¤ãƒ³å´ã‚¨ãƒ©ãƒ¼ ã«é™å®šï¼ˆSQL/HTTP ã®ç”Ÿã‚¨ãƒ©ãƒ¼ã¯ã“ã“ã«å‡ºã•ãªã„ï¼‰

```rust
// domain/src/repository/content_repository.rs
#[async_trait]
trait ContentRepository {
  async fn find_by_id(&self, id: &ContentId) -> Result<Content, RepoError>;
  async fn save(&self, content: &Content) -> Result<(), RepoError>;
}
```

### Step 3: Use Case ã‚’æ›¸ãï¼ˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã ã‘ï¼‰

- å–å¾— â†’ å…¬é–‹ â†’ ä¿å­˜ â†’Webhookâ†’ ãƒ¡ãƒ¼ãƒ«ã®é †ç•ªã‚’å®šã‚ã‚‹
- SQL/HTTP ã¯ç¦æ­¢ã€Port å‘¼ã³å‡ºã—ã®ã¿ã€‚ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¢ƒç•Œã‚‚ã“ã“ã§

```rust
// application/src/usecase/content.rs
impl ContentUsecase {
    pub async fn publish(&self, id: &ContentId) -> Result<(), AppError> {
        let mut content = self.repo.find_by_id(id).await?;
        content.publish().map_err(AppError::Validation)?;
        self.repo.save(&content).await?;
        self.webhook.publish_content(id).await?;
        self.mail.send_published_notice(id).await?;
        Ok(())
    }
}
```

### Step 4: Adapterï¼ˆã‚¤ãƒ³ãƒ•ãƒ©è©³ç´°ã¯ã“ã“ã ã‘ï¼‰

- ContentRepository ã‚’ sqlxï¼ˆPostgresï¼‰ã§å®Ÿè£…ã€ã‚¨ãƒ©ãƒ¼ã¯ RepoError ã¸å¤‰æ›
- WebhookPublisher / MailSender ã¯ HTTP/SMTP ã‚’å©ãã€AppError::Infra ã¸æ­£è¦åŒ–

> DB/HTTP ã®å…·ä½“ã¯ã™ã¹ã¦ Adapter ã«éš”é›¢ã€‚ Domain/Application ã«æ¼ã‚‰ã•ãªã„ã€‚

```rust
// infrastructure/src/database/content_repository_pg.rs
#[async_trait::async_trait]
impl ContentRepository for ContentRepositoryPg {
    async fn find_by_id(&self, id: &ContentId) -> Result<Content, RepoError> {
        let rec = sqlx::query!(
            r#"
            SELECT id, title, body, status
            FROM contents
            WHERE id = $1
            "#,
            id.0
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| RepoError::Infra(e.to_string()))?;

        let r = rec.ok_or(RepoError::NotFound)?;
        let status = match r.status.as_str() {
            "published" => ContentStatus::Published,
            _ => ContentStatus::Draft,
        };

        Ok(Content {
            id: ContentId(r.id),
            title: r.title,
            body: r.body,
            status,
        })
    }

    async fn save(&self, c: &Content) -> Result<(), RepoError> {
        let status = match c.status {
            ContentStatus::Published => "published",
            ContentStatus::Draft => "draft",
        };

        sqlx::query!(
            r#"
            UPDATE contents
            SET title = $1, body = $2, status = $3
            WHERE id = $4
            "#,
            c.title,
            c.body,
            status,
            c.id.0
        )
        .execute(&self.pool)
        .await
        .map_err(|e| RepoError::Infra(e.to_string()))?;

        Ok(())
    }
}
```

### Step 5: Registryï¼ˆé…ç·šï¼‰

- æœ¬ç•ªã¯ ContentRepositoryPg / WebhookHttp / MailSmtp ã‚’ PublishContentUsecase ã«æ³¨å…¥
- ãƒ†ã‚¹ãƒˆæ™‚ã¯ fake / in-memory ã«å·®ã—æ›¿ãˆå¯èƒ½ã«

```rust
// registry/src/lib.rs
use std::sync::Arc;
use sqlx::PgPool;

use application::usecase::content::ContentUsecase;
use infrastructure::{
    database::content_repository_pg::ContentRepositoryPg,
    webhook::publisher_http::WebhookPublisherHttp,
    mail::sender_smtp::MailSenderSmtp,
};

pub struct AppRegistry {
    pub content_usecase: ContentUsecase,
}

impl AppRegistry {
    pub fn new(pool: PgPool, webhook_url: String, smtp_url: String, from: String, to: String)
        -> anyhow::Result<Self>
    {
        let repo    = Arc::new(ContentRepositoryPg { pool });
        let webhook = Arc::new(WebhookPublisherHttp::new(webhook_url));
        let mail    = Arc::new(MailSenderSmtp::new(&smtp_url, from, to)?);

        let content_usecase = ContentUsecase::new(repo, webhook, mail);

        Ok(Self { content_usecase })
    }
}
```

### Step 6: HTTP Handlerï¼ˆè–„ãä¿ã¤ï¼‰

```rust
// interface/src/web/handler/content.rs
use axum::{extract::{Path, State}, http::StatusCode};
use crate::registry::AppRegistry;
use domain::model::content::ContentId;

#[utoipa::path(
    post,
    path = "/contents/{id}/publish",
    params( ("id" = String, Path, description = "Content ID") ),
    responses( (status = 204, description = "Publish content success") ),
    tag = "contents",
)]
#[tracing::instrument(skip_all)]
pub async fn publish_content(
    State(registry): State<AppRegistry>,
    Path(id): Path<String>,
) -> Result<StatusCode, AppError> {
    let content_id = ContentId(id);
    registry.content_usecase.publish(&content_id).await?;
    Ok(StatusCode::NO_CONTENT)
}
```

### Step 7: ãƒ†ã‚¹ãƒˆã¯å±¤ã”ã¨ï¼ˆå†… â†’ å¤–ï¼‰

1. Domainï¼špublish() ã®æˆåŠŸ/å¤±æ•—
2. Applicationï¼šfake repo/webhook/mail ã§ãƒãƒƒãƒ”ãƒ¼ãƒ‘ã‚¹ï¼†ã‚¨ãƒ©ãƒ¼åˆ†å²
3. Infrastructureï¼šå¿…è¦ç®‡æ‰€ã®ã¿ DB/API çµ±åˆãƒ†ã‚¹ãƒˆ
4. Interfaceï¼šã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ 204/4xx ã‚’æ­£ã—ãè¿”ã™ã‹

## ã¾ã¨ã‚

æœ¬ç¨¿ã§ã¯ã€DDD ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸­å¿ƒã®æ€è€ƒæ³•ã¨ã—ã¦æ‰ãˆã€Rust ã§ã®æˆ¦è¡“çš„ DDD ã®æœ€å°ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆDomainâ†’Portâ†’Use Caseâ†’Adapterâ†’Wiringâ†’Handlerâ†’Testï¼‰ã¨ã€POST /contents/:id/publish ã®ã‚¹ã‚¿ãƒ‡ã‚£ã‚±ãƒ¼ã‚¹ã§å…·ä½“åŒ–ã—ã¦ã¿ã¾ã—ãŸã€‚ãƒã‚¤ãƒ³ãƒˆã¯ ã€Œãƒ«ãƒ¼ãƒ«ã¯ Domain ã«ã€èª¿åœã¯ Use Case ã«ã€I/O ã¯ Adapter ã«ã€ ã®åˆ†é›¢ã§ã™ã€‚

èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ã¾ã è’å‰Šã‚Šãªéƒ¨åˆ†ã‚‚ã‚ã‚‹ã¨æ€ã„ã¾ã™ãŒã€ã¿ãªã•ã‚“ã®ç¾å ´ã§å°‘ã—ã§ã‚‚æŒ‡é‡ã«ãªã‚Œã°ã†ã‚Œã—ã„ã§ã™ã€‚ã”æ„è¦‹ãƒ»è³ªå•ãƒ»æ”¹å–„ã‚¢ã‚¤ãƒ‡ã‚¢ãªã©ã€ãœã²æ°—è»½ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãã ã•ã„ã€‚ä»Šå¾Œã‚‚å®Ÿè·µã‹ã‚‰ã®å­¦ã³ã‚’å…±æœ‰ã—ã¦ã„ãã¾ã™ï¼
